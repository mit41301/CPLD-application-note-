/**************************************************************************************************************
* NAND FLASH INTERFACE
* March, 2007
**************************************************************************************************************/
`timescale 1 ns/1 ns
module nand_interface (h_rd_wr,       //Active high read,active low write signal generated by the host for the interface
                       h_cntrl,       //Control signal generated by the host to determine which function 
                                      //the interface will currently perform  
                       e_d,           //Enable-Disable signal generated by the host 
                       reset,         //Reset signal aborts the current operation and resets all the control siganls
                       ce,            //Chip enable,it controls the active vs standby mode of the device 
                       re,            //Read enable,it controls the data and status output on the I/O lines
                       ale,           //Address latch enable,it controls the writing to the address register 
                       cle,           //Command latch enable,it controls the writing to the command register
                       se,            //Spare area enable,it controls the access to the 16 byte of spare area on each page
                       we,            //Write enable,it controls the data and command on the I/O lines during a write sequence
                       wp            //Write protect,it provides the protection when programming or erasing the device
                       );

input h_rd_wr,reset,e_d;
input [2:0] h_cntrl;

output ce,re,ale;
output cle,se,we,wp;

wire n_ce,n_wp,n_ale,n_se ;
reg int_ce,int_wp,int_ale,int_se;

assign n_ce = int_ce;
assign n_wp = int_wp;
assign n_ale = int_ale;
assign n_se = int_se;

assign ce = n_ce;
assign wp = n_wp;
assign ale = n_ale;
assign se = n_se;

					    
/* multiplexed bus on which command or data is put */

wire decod0,decod1,decod2,decod3,decod4,decod5,decod6,decod7;

// command latch enable
assign decod0 = ((~h_cntrl[2]) & (~h_cntrl[1]) & (~h_cntrl[0])); 
// read data or device id 
assign decod1 = ((~h_cntrl[2]) & (~h_cntrl[1]) & (h_cntrl[0]));
 // write data or command  
assign decod2 = ((~h_cntrl[2]) & (h_cntrl[1]) & (~h_cntrl[0]));  
 // address latch enable   
assign decod3 = ((~h_cntrl[2]) & (h_cntrl[1]) & (h_cntrl[0]));
// spare area enable        
assign decod4 = ((h_cntrl[2])& (~h_cntrl[1]) & (~h_cntrl[0]));
// write protect enable      
assign decod5 = ((h_cntrl[2]) & (~h_cntrl[1]) & (h_cntrl[0]));
 // chip enable         
assign decod6 = ((h_cntrl[2]) & (h_cntrl[1]) & (~h_cntrl[0]));        
 // ready_busy
assign decod7 = ((h_cntrl[2]) & (h_cntrl[1]) & (h_cntrl[0]));           

assign cle = decod0;

assign re = (!(h_rd_wr & decod1));

assign we = (!((!h_rd_wr) & decod2));
 
always @(reset,decod3,e_d) 
begin   
    if (reset)begin
        int_ale <= 1'b0;
    end else if (decod3)begin
        case (e_d)
            1'b0 : int_ale <= 1'b0;					// n_ale = e_d;
            1'b1 : int_ale <= 1'b1;
	    endcase
	end
end

always @(reset,decod4,e_d) 
begin  
    if (reset) begin
        int_se <= 1'b1;
    end else if (decod4)begin
        case (e_d)
            1'b0 : int_se <= 1'b1;					// n_se = !(e_d);
            1'b1 : int_se <= 1'b0;
	    endcase
	end
end

always @(reset,decod5,e_d) 
begin 
    if (reset)begin
        int_wp <= 1'b0;
    end else if (decod5)begin
        case (e_d)
            1'b0 : int_wp <= 1'b1;					// n_wp = !(e_d);
            1'b1 : int_wp <= 1'b0;
	    endcase
	end
end

always @(reset,decod6,e_d)
begin 
    if (reset)begin
        int_ce <= 1'b0;
    end else if (decod6)begin
        case (e_d)
            1'b0 : int_ce <= 1'b1;					// n_ce = !(e_d);
            1'b1 : int_ce <= 1'b0;
	    endcase
	end
end
endmodule

/*************************************************** END **********************************************************************/